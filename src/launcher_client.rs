use anyhow::Result;
use std::path::PathBuf;
use tokio::io::{AsyncBufReadExt, AsyncWriteExt, BufReader};
use tokio::net::UnixStream;
use tokio::task::JoinHandle;
use portable_pty::MasterPty;

use crate::ansi_utils::clean_for_logging;

use crate::claude_wrapper::ClaudeWrapper;
use crate::monitor_server::MonitorServer;
use crate::process_monitor::ProcessMonitor;
use crate::protocol::{
    LauncherToMonitor, generate_connection_id
};
use crate::standard_analyzer::StandardAnalyzer;

/// Launcher „ÇØ„É©„Ç§„Ç¢„É≥„Éà
pub struct LauncherClient {
    launcher_id: String,
    socket_stream: Option<UnixStream>,
    claude_wrapper: ClaudeWrapper,
    process_monitor: ProcessMonitor,
    output_analyzer: StandardAnalyzer,
    project_name: Option<String>,
    session_id: String,
    verbose: bool,
    log_file: Option<PathBuf>,
}

impl LauncherClient {
    /// Êñ∞„Åó„ÅÑLauncherClient„Çí‰ΩúÊàê
    pub fn new(claude_args: Vec<String>, verbose: bool) -> Self {
        let launcher_id = generate_connection_id();
        let session_id = format!("session-{:x}", std::time::SystemTime::now().duration_since(std::time::UNIX_EPOCH).unwrap().as_millis());
        let claude_wrapper = ClaudeWrapper::new(claude_args);
        let project_name = claude_wrapper.guess_project_name();

        Self {
            launcher_id,
            socket_stream: None,
            claude_wrapper,
            process_monitor: ProcessMonitor::new(),
            output_analyzer: StandardAnalyzer::new(),
            project_name,
            session_id,
            verbose,
            log_file: None,
        }
    }

    /// „É≠„Ç∞„Éï„Ç°„Ç§„É´„ÇíË®≠ÂÆö
    pub fn set_log_file(&mut self, log_file: Option<PathBuf>) {
        self.log_file = log_file;
    }

    /// Monitor „Çµ„Éº„Éê„Éº„Å´Êé•Á∂ö
    pub async fn connect_to_monitor(&mut self) -> Result<()> {
        let socket_path = MonitorServer::get_client_socket_path()?;
        
        let stream = UnixStream::connect(&socket_path).await
            .map_err(|e| anyhow::anyhow!("Failed to connect to monitor: {}", e))?;

        self.socket_stream = Some(stream);

        if self.verbose {
            println!("‚úÖ Connected to monitor server");
        }

        // Êé•Á∂ö„É°„ÉÉ„Çª„Éº„Ç∏ÈÄÅ‰ø°
        self.send_connect_message().await?;

        // Monitor „Åã„Çâ„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÂèó‰ø°„Åó„Å¶„É≠„Ç∞„Éï„Ç°„Ç§„É´Ë®≠ÂÆö„ÇíÂèñÂæó
        self.receive_initial_config().await?;

        Ok(())
    }

    /// Êé•Á∂ö„É°„ÉÉ„Çª„Éº„Ç∏ÈÄÅ‰ø°
    async fn send_connect_message(&mut self) -> Result<()> {
        let working_dir = std::env::current_dir()
            .unwrap_or_else(|_| PathBuf::from("/"));

        let message = LauncherToMonitor::Connect {
            launcher_id: self.launcher_id.clone(),
            project: self.project_name.clone(),
            claude_args: self.claude_wrapper.get_args().to_vec(),
            working_dir,
            timestamp: chrono::Utc::now(),
        };

        self.send_message(message).await?;

        if self.verbose {
            println!("üì° Sent connection message to monitor");
        }

        Ok(())
    }

    /// Monitor „Åã„Çâ„ÅÆÂàùÊúüË®≠ÂÆö„ÇíÂèó‰ø°
    async fn receive_initial_config(&mut self) -> Result<()> {
        use crate::protocol::MonitorToLauncher;

        if let Some(ref mut stream) = self.socket_stream {
            let mut reader = BufReader::new(stream);
            let mut buffer = String::new();
            
            // „Çø„Ç§„É†„Ç¢„Ç¶„Éà‰ªò„Åç„Åß„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÂèó‰ø°
            match tokio::time::timeout(
                tokio::time::Duration::from_secs(2),
                reader.read_line(&mut buffer)
            ).await {
                Ok(Ok(n)) if n > 0 => {
                    if let Ok(message) = serde_json::from_str::<MonitorToLauncher>(&buffer.trim()) {
                        match message {
                            MonitorToLauncher::SetLogFile { log_file_path } => {
                                self.log_file = log_file_path;
                                if self.verbose {
                                    if let Some(ref path) = self.log_file {
                                        println!("üìù Log file configured: {}", path.display());
                                    }
                                }
                            }
                            _ => {
                                // ‰ªñ„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏„ÅØÁÑ°Ë¶ñ
                            }
                        }
                    }
                }
                _ => {
                    // „Çø„Ç§„É†„Ç¢„Ç¶„Éà„Åæ„Åü„ÅØ‰ªñ„ÅÆ„Ç®„É©„ÉºÔºö„É≠„Ç∞„Éï„Ç°„Ç§„É´Ë®≠ÂÆö„Å™„Åó„Å®„Åó„Å¶Á∂öË°å
                    if self.verbose {
                        println!("‚è∞ No log file configuration received");
                    }
                }
            }
        }

        Ok(())
    }

    /// Claude „Éó„É≠„Çª„ÇπËµ∑Âãï„ÉªÁõ£Ë¶ñ
    pub async fn run_claude(&mut self) -> Result<()> {
        if self.verbose {
            println!("üöÄ Starting Claude: {}", self.claude_wrapper.to_command_string());
        }

        // Monitor „Å´Êé•Á∂ö„Åß„Åç„Å¶„ÅÑ„Å™„ÅÑÂ†¥Âêà„ÅØÂçòÁ¥î„Å´ClaudeÂÆüË°å
        if !self.is_connected() {
            if self.verbose {
                println!("üîÑ Running Claude without monitoring (monitor not connected)");
            }
            return self.claude_wrapper.run_directly().await;
        }

        // Claude „Éó„É≠„Çª„ÇπËµ∑ÂãïÔºàPTY„Çí‰ΩøÁî®„Åó„Å¶TTYÁí∞Â¢É„ÇíÊèê‰æõÔºâ
        let (mut claude_process, pty_master) = self.claude_wrapper.spawn_with_pty()?;
        // Note: std::process::Child „ÅØ set_process „Å´Ê∏°„Åõ„Å™„ÅÑ„Åü„ÇÅ„ÄÅ„Éó„É≠„Çª„ÇπÁõ£Ë¶ñ„ÅØÁúÅÁï•

        // PTY„Éô„Éº„Çπ„ÅÆÂèåÊñπÂêëI/OÈñãÂßã
        let pty_handle = self.start_pty_bidirectional_io(pty_master).await?;

        // „Éó„É≠„Çª„ÇπÁõ£Ë¶ñÈñãÂßã
        let process_handle = self.start_process_monitoring().await;

        if self.verbose {
            println!("üëÄ Monitoring started for Claude process");
        }

        // Claude „Éó„É≠„Çª„Çπ„ÅÆÁµÇ‰∫Ü„ÇíÂæÖ„Å§Ôºàportable_pty::Child „Å™„ÅÆ„Åß tokio::task::spawn_blocking „Çí‰ΩøÁî®Ôºâ
        let exit_status = tokio::task::spawn_blocking(move || {
            claude_process.wait()
        }).await??;

        if self.verbose {
            println!("üèÅ Claude process exited with status: {:?}", exit_status);
        }

        // Áõ£Ë¶ñ„Çø„Çπ„ÇØ„ÇíÁµÇ‰∫Ü
        pty_handle.abort();
        process_handle.abort();

        // ÂàáÊñ≠„É°„ÉÉ„Çª„Éº„Ç∏ÈÄÅ‰ø°
        self.send_disconnect_message().await?;

        Ok(())
    }

    /// stdout Áõ£Ë¶ñ„Çø„Çπ„ÇØÈñãÂßã
    async fn start_stdout_monitoring(&self, claude_process: &mut tokio::process::Child) -> Result<JoinHandle<()>> {
        let stdout = claude_process.stdout.take()
            .ok_or_else(|| anyhow::anyhow!("Failed to capture stdout"))?;

        let launcher_id = self.launcher_id.clone();
        let session_id = self.session_id.clone();
        let verbose = self.verbose;
        let log_file = self.log_file.clone();

        let handle = tokio::spawn(async move {
            Self::monitor_output_stream(
                stdout,
                launcher_id,
                session_id,
                "stdout".to_string(),
                verbose,
                log_file,
            ).await;
        });

        Ok(handle)
    }

    /// stderr Áõ£Ë¶ñ„Çø„Çπ„ÇØÈñãÂßã
    async fn start_stderr_monitoring(&self, claude_process: &mut tokio::process::Child) -> Result<JoinHandle<()>> {
        let stderr = claude_process.stderr.take()
            .ok_or_else(|| anyhow::anyhow!("Failed to capture stderr"))?;

        let launcher_id = self.launcher_id.clone();
        let session_id = self.session_id.clone();
        let verbose = self.verbose;
        let log_file = self.log_file.clone();

        let handle = tokio::spawn(async move {
            Self::monitor_output_stream(
                stderr,
                launcher_id,
                session_id,
                "stderr".to_string(),
                verbose,
                log_file,
            ).await;
        });

        Ok(handle)
    }

    /// Âá∫Âäõ„Çπ„Éà„É™„Éº„É†Áõ£Ë¶ñ
    async fn monitor_output_stream(
        stream: impl tokio::io::AsyncRead + Unpin,
        _launcher_id: String,
        _session_id: String,
        stream_name: String,
        verbose: bool,
        log_file: Option<PathBuf>,
    ) {
        let mut reader = BufReader::new(stream);
        let mut buffer = String::new();
        let mut analyzer = StandardAnalyzer::new();

        // „É≠„Ç∞„Éï„Ç°„Ç§„É´„ÇíÈñã„ÅèÔºàstdout „ÅÆ„ÅøÔºâ
        let mut log_writer = if stream_name == "stdout" {
            if let Some(ref log_path) = log_file {
                match tokio::fs::OpenOptions::new()
                    .create(true)
                    .append(true)
                    .open(log_path)
                    .await
                {
                    Ok(file) => Some(file),
                    Err(e) => {
                        if verbose {
                            eprintln!("‚ö†Ô∏è  Failed to open log file {}: {}", log_path.display(), e);
                        }
                        None
                    }
                }
            } else {
                None
            }
        } else {
            None
        };

        loop {
            buffer.clear();
            
            match reader.read_line(&mut buffer).await {
                Ok(0) => break, // EOF
                Ok(_) => {
                    let line = buffer.trim();
                    
                    // „É¶„Éº„Ç∂„Éº„Å´„ÅØÈÄöÂ∏∏ÈÄö„ÇäÂá∫ÂäõË°®Á§∫
                    match stream_name.as_str() {
                        "stdout" => println!("{}", line),
                        "stderr" => eprintln!("{}", line),
                        _ => {}
                    }

                    if verbose {
                        println!("üìù [{}] {}", stream_name, line);
                    }

                    // „É≠„Ç∞„Éï„Ç°„Ç§„É´„Å´Êõ∏„ÅçËæº„ÅøÔºàstdout „ÅÆ„Åø„ÄÅANSI „Ç®„Çπ„Ç±„Éº„Éó„Ç∑„Éº„Ç±„É≥„Çπ„Çí„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„ÉóÔºâ
                    if let Some(ref mut writer) = log_writer {
                        let clean_line = clean_for_logging(line);
                        let log_line = format!("{}\n", clean_line);
                        if let Err(e) = writer.write_all(log_line.as_bytes()).await {
                            if verbose {
                                eprintln!("‚ö†Ô∏è  Failed to write to log file: {}", e);
                            }
                        } else {
                            // „Éï„É©„ÉÉ„Ç∑„É•„Åó„Å¶Á¢∫ÂÆü„Å´Êõ∏„ÅçËæº„Åø
                            let _ = writer.flush().await;
                        }
                    }

                    // Âá∫Âäõ„ÇíËß£Êûê
                    let _analysis = analyzer.analyze_output(line, &stream_name);
                    
                    // TODO: Monitor „Å´ÈÄÅ‰ø°
                    // „Åì„ÅÆ„Çª„ÇØ„Ç∑„Éß„É≥„ÅØÂæå„ÅßÂÆüË£Ö
                }
                Err(e) => {
                    if verbose {
                        eprintln!("üì° Read error from {}: {}", stream_name, e);
                    }
                    break;
                }
            }
        }
    }

    /// PTY ÂèåÊñπÂêëI/O„Çø„Çπ„ÇØÈñãÂßã
    async fn start_pty_bidirectional_io(&self, pty_master: Box<dyn MasterPty + Send>) -> Result<JoinHandle<()>> {
        let launcher_id = self.launcher_id.clone();
        let session_id = self.session_id.clone();
        let verbose = self.verbose;
        let log_file = self.log_file.clone();

        let handle = tokio::spawn(async move {
            Self::handle_pty_bidirectional_io(
                pty_master,
                launcher_id,
                session_id,
                verbose,
                log_file,
            ).await;
        });

        Ok(handle)
    }

    /// PTY ÂèåÊñπÂêëI/OÂá¶ÁêÜÔºàstdin ‚Üí PTY, PTY ‚Üí stdout + logÔºâ
    async fn handle_pty_bidirectional_io(
        pty_master: Box<dyn MasterPty + Send>,
        _launcher_id: String,
        _session_id: String,
        verbose: bool,
        log_file: Option<PathBuf>,
    ) {
        let analyzer = StandardAnalyzer::new();

        // „É≠„Ç∞„Éï„Ç°„Ç§„É´„ÇíÈñã„Åè
        let log_writer = if let Some(ref log_path) = log_file {
            match tokio::fs::OpenOptions::new()
                .create(true)
                .append(true)
                .open(log_path)
                .await
            {
                Ok(file) => Some(file),
                Err(e) => {
                    if verbose {
                        eprintln!("‚ö†Ô∏è  Failed to open log file {}: {}", log_path.display(), e);
                    }
                    None
                }
            }
        } else {
            None
        };

        // PTY writer „Çí‰∏ÄÂ∫¶„Å†„ÅëÂèñÂæóÔºàtake_writer „ÅØ‰∏ÄÂ∫¶„Åó„ÅãÂëº„Åπ„Å™„ÅÑÔºâ
        let pty_writer = match pty_master.take_writer() {
            Ok(writer) => writer,
            Err(e) => {
                if verbose {
                    eprintln!("‚ö†Ô∏è  Failed to get PTY writer: {}", e);
                }
                return;
            }
        };

        // PTY reader „ÇíÂèñÂæó
        let pty_reader = match pty_master.try_clone_reader() {
            Ok(reader) => reader,
            Err(e) => {
                if verbose {
                    eprintln!("‚ö†Ô∏è  Failed to get PTY reader: {}", e);
                }
                return;
            }
        };

        // ÂèåÊñπÂêëI/O„Çø„Çπ„ÇØ„ÇíËµ∑Âãï
        let pty_to_stdout = tokio::spawn(async move {
            Self::handle_pty_to_stdout(
                pty_reader,
                verbose,
                log_writer,
                analyzer,
            ).await;
        });

        let stdin_to_pty = tokio::spawn(async move {
            // „Ç§„É≥„Çø„É©„ÇØ„ÉÜ„Ç£„Éñ„Çø„Éº„Éü„Éä„É´„Åã„Å©„ÅÜ„Åã„ÉÅ„Çß„ÉÉ„ÇØ
            let is_interactive = std::io::IsTerminal::is_terminal(&std::io::stdin());
            
            if is_interactive {
                if verbose {
                    println!("üìù [pty] Using raw input mode for interactive terminal");
                }
                Self::handle_stdin_to_pty_raw(pty_writer, verbose).await;
            } else {
                if verbose {
                    println!("üìù [pty] Using standard input mode for non-interactive input");
                }
                Self::handle_stdin_to_pty(pty_writer, verbose).await;
            }
        });

        // „Å©„Å°„Çâ„Åã„ÅÆ„Çø„Çπ„ÇØ„ÅåÁµÇ‰∫Ü„Åó„Åü„Çâ‰∏°ÊñπÁµÇ‰∫Ü
        tokio::select! {
            _ = pty_to_stdout => {
                if verbose {
                    println!("üì° PTY to stdout task ended");
                }
            }
            _ = stdin_to_pty => {
                if verbose {
                    println!("üì° Stdin to PTY task ended");
                }
            }
        }
    }

    /// PTY ‚Üí stdout + log Ëª¢ÈÄÅÂá¶ÁêÜ
    async fn handle_pty_to_stdout(
        pty_reader: Box<dyn std::io::Read + Send>,
        verbose: bool,
        mut log_writer: Option<tokio::fs::File>,
        mut analyzer: StandardAnalyzer,
    ) {
        use std::sync::{Arc, Mutex};
        let pty_reader = Arc::new(Mutex::new(pty_reader));
        
        loop {
            let mut buffer = [0u8; 4096];
            let result = tokio::task::spawn_blocking({
                let pty_reader = pty_reader.clone();
                move || {
                    use std::io::Read;
                    let mut reader = pty_reader.lock().unwrap();
                    let bytes_read = reader.read(&mut buffer)?;
                    Ok::<(Vec<u8>, usize), std::io::Error>((buffer.to_vec(), bytes_read))
                }
            }).await;

            match result {
                Ok(Ok((_buffer_data, 0))) => break, // EOF
                Ok(Ok((buffer_data, n))) => {
                    let output = String::from_utf8_lossy(&buffer_data[..n]);
                    
                    // „É¶„Éº„Ç∂„Éº„Å´„ÅØÈÄöÂ∏∏ÈÄö„ÇäÂá∫ÂäõË°®Á§∫
                    print!("{}", output);
                    use std::io::Write;
                    std::io::stdout().flush().unwrap();

                    if verbose {
                        println!("üìù [pty‚Üístdout] {}", output.trim());
                    }

                    // „É≠„Ç∞„Éï„Ç°„Ç§„É´„Å´Êõ∏„ÅçËæº„ÅøÔºà„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„ÉóÊ∏à„ÅøÔºâ
                    if let Some(ref mut writer) = log_writer {
                        let clean_output = clean_for_logging(&output);
                        if let Err(e) = writer.write_all(clean_output.as_bytes()).await {
                            if verbose {
                                eprintln!("‚ö†Ô∏è  Failed to write to log file: {}", e);
                            }
                        } else {
                            // „Éï„É©„ÉÉ„Ç∑„É•„Åó„Å¶Á¢∫ÂÆü„Å´Êõ∏„ÅçËæº„Åø
                            let _ = writer.flush().await;
                        }
                    }

                    // Âá∫Âäõ„ÇíËß£Êûê
                    let _analysis = analyzer.analyze_output(&output, "pty");
                    
                    // TODO: Monitor „Å´ÈÄÅ‰ø°
                    // „Åì„ÅÆ„Çª„ÇØ„Ç∑„Éß„É≥„ÅØÂæå„ÅßÂÆüË£Ö
                }
                Ok(Err(e)) => {
                    if verbose {
                        eprintln!("üì° Read error from PTY: {}", e);
                    }
                    break;
                }
                Err(e) => {
                    if verbose {
                        eprintln!("üì° Spawn blocking error: {}", e);
                    }
                    break;
                }
            }
        }
    }

    /// stdin ‚Üí PTY Ëª¢ÈÄÅÂá¶ÁêÜÔºàUTF-8„Éû„É´„ÉÅ„Éê„Ç§„ÉàÊñáÂ≠óÂØæÂøúÔºâ
    async fn handle_stdin_to_pty(
        pty_writer: Box<dyn std::io::Write + Send>,
        verbose: bool,
    ) {
        use tokio::io::{AsyncReadExt};
        use std::sync::{Arc, Mutex};
        use std::io::{self, IsTerminal};
        
        let pty_writer = Arc::new(Mutex::new(pty_writer));
        
        // „Çø„Éº„Éü„Éä„É´„ÅåTTY„Åã„Å©„ÅÜ„Åã„ÇíÁ¢∫Ë™ç
        if verbose {
            println!("üìù [stdin‚Üípty] TTY check: stdin={}, stdout={}, stderr={}", 
                io::stdin().is_terminal(),
                io::stdout().is_terminal(), 
                io::stderr().is_terminal()
            );
        }
        
        let mut stdin = tokio::io::stdin();
        let mut buffer = [0u8; 1024];
        let mut byte_buffer = Vec::new(); // „Éê„Ç§„Éà„É¨„Éô„É´„Åß„ÅÆ„Éê„ÉÉ„Éï„Ç°„É™„É≥„Ç∞

        if verbose {
            println!("üìù [stdin‚Üípty] Starting input reading loop");
        }

        loop {
            if verbose {
                println!("üìù [stdin‚Üípty] Waiting for stdin input...");
            }
            match stdin.read(&mut buffer).await {
                Ok(0) => break, // EOF
                Ok(n) => {
                    // Ë™≠„ÅøÂèñ„Å£„Åü„Éê„Ç§„Éà„ÇíÁ¥ØÁ©ç„Éê„ÉÉ„Éï„Ç°„Å´ËøΩÂä†
                    byte_buffer.extend_from_slice(&buffer[..n]);
                    
                    // UTF-8ÊñáÂ≠óÂ¢ÉÁïå„ÇíË¶ã„Å§„Åë„Å¶Âá¶ÁêÜ
                    let mut processed_bytes = 0;
                    
                    while processed_bytes < byte_buffer.len() {
                        // ÊÆã„Çä„ÅÆ„Éê„Ç§„Éà„ÅßUTF-8ÊñáÂ≠ó„ÅÆÈñãÂßã„ÇíÊé¢„Åô
                        let remaining = &byte_buffer[processed_bytes..];
                        
                        // UTF-8ÊñáÂ≠ó„Å®„Åó„Å¶ÊúâÂäπ„Å™ÊúÄÂ§ßÈï∑„ÇíË¶ã„Å§„Åë„Çã
                        match std::str::from_utf8(remaining) {
                            Ok(valid_str) => {
                                // ÂÖ®„Å¶ÊúâÂäπ„Å™UTF-8ÊñáÂ≠óÂàó
                                if !valid_str.is_empty() {
                                    if verbose {
                                        // Âà∂Âæ°ÊñáÂ≠ó„ÇíÂèØË¶ñÂåñ„Åó„Å¶Ë°®Á§∫
                                        let display_input = valid_str.replace('\n', "\\n").replace('\r', "\\r");
                                        println!("üìù [stdin‚Üípty] \"{}\" (bytes: {:?})", display_input, valid_str.as_bytes());
                                    }

                                    // PTY„Å´Êõ∏„ÅçËæº„Åø
                                    let result = tokio::task::spawn_blocking({
                                        let pty_writer = pty_writer.clone();
                                        let input = valid_str.to_string();
                                        move || {
                                            use std::io::Write;
                                            let mut writer = pty_writer.lock().unwrap();
                                            writer.write_all(input.as_bytes())?;
                                            writer.flush()?;
                                            Ok::<(), std::io::Error>(())
                                        }
                                    }).await;

                                    if let Err(e) = result {
                                        if verbose {
                                            eprintln!("üì° Spawn blocking error for stdin write: {}", e);
                                        }
                                        break;
                                    } else if let Err(e) = result.unwrap() {
                                        if verbose {
                                            eprintln!("üì° Write error to PTY: {}", e);
                                        }
                                        break;
                                    }
                                }
                                
                                // ÂÖ®‰Ωì„ÇíÂá¶ÁêÜÂÆå‰∫Ü
                                processed_bytes = byte_buffer.len();
                                break;
                            }
                            Err(utf8_error) => {
                                // ‰∏ÄÈÉ®„Å†„ÅëÊúâÂäπ„ÄÅ„Åæ„Åü„ÅØ‰∏çÂÆåÂÖ®„Å™UTF-8„Ç∑„Éº„Ç±„É≥„Çπ
                                let valid_up_to = utf8_error.valid_up_to();
                                
                                if valid_up_to > 0 {
                                    // ÊúâÂäπ„Å™ÈÉ®ÂàÜ„ÇíÂá¶ÁêÜ
                                    let valid_part = &remaining[..valid_up_to];
                                    if let Ok(valid_str) = std::str::from_utf8(valid_part) {
                                        if !valid_str.is_empty() {
                                            if verbose {
                                                let display_input = valid_str.replace('\n', "\\n").replace('\r', "\\r");
                                                println!("üìù [stdin‚Üípty] \"{}\" (bytes: {:?})", display_input, valid_str.as_bytes());
                                            }

                                            // ÊúâÂäπÈÉ®ÂàÜ„ÇíPTY„Å´Êõ∏„ÅçËæº„Åø
                                            let result = tokio::task::spawn_blocking({
                                                let pty_writer = pty_writer.clone();
                                                let input = valid_str.to_string();
                                                move || {
                                                    use std::io::Write;
                                                    let mut writer = pty_writer.lock().unwrap();
                                                    writer.write_all(input.as_bytes())?;
                                                    writer.flush()?;
                                                    Ok::<(), std::io::Error>(())
                                                }
                                            }).await;

                                            if let Err(e) = result {
                                                if verbose {
                                                    eprintln!("üì° Spawn blocking error for stdin write: {}", e);
                                                }
                                                break;
                                            } else if let Err(e) = result.unwrap() {
                                                if verbose {
                                                    eprintln!("üì° Write error to PTY: {}", e);
                                                }
                                                break;
                                            }
                                        }
                                    }
                                    processed_bytes += valid_up_to;
                                } else {
                                    // ÊúÄÂàù„Åã„ÇâÁÑ°Âäπ - ‰∏çÂÆåÂÖ®„Å™UTF-8„Ç∑„Éº„Ç±„É≥„Çπ„ÅÆÂèØËÉΩÊÄß
                                    // Ê¨°„ÅÆË™≠„ÅøÂèñ„Çä„ÇíÂæÖ„Å§„Åü„ÇÅ„Å´„É´„Éº„Éó„ÇíÊäú„Åë„Çã
                                    break;
                                }
                            }
                        }
                    }
                    
                    // Âá¶ÁêÜÊ∏à„Åø„Éê„Ç§„Éà„Çí„Éê„ÉÉ„Éï„Ç°„Åã„ÇâÂâäÈô§
                    if processed_bytes > 0 {
                        byte_buffer.drain(..processed_bytes);
                    }
                    
                    // „Éê„ÉÉ„Éï„Ç°„ÅåÂ§ß„Åç„Åè„Å™„Çä„Åô„Åé„ÅüÂ†¥Âêà„ÅÆ„Ç¨„Éº„ÉâÔºàÁÑ°Âäπ„Å™„Éá„Éº„Çø„ÅÆËìÑÁ©ç„ÇíÈò≤„ÅêÔºâ
                    if byte_buffer.len() > 16 {
                        if verbose {
                            eprintln!("‚ö†Ô∏è  Clearing input buffer due to invalid UTF-8 sequence");
                        }
                        byte_buffer.clear();
                    }
                }
                Err(e) => {
                    if verbose {
                        eprintln!("üì° Read error from stdin: {}", e);
                    }
                    break;
                }
            }
        }
    }

    /// stdin ‚Üí PTY Ëª¢ÈÄÅÂá¶ÁêÜÔºàRaw„É¢„Éº„Éâ - Áõ¥Êé•„Çø„Éº„Éü„Éä„É´ÂÖ•ÂäõÔºâ
    async fn handle_stdin_to_pty_raw(
        pty_writer: Box<dyn std::io::Write + Send>,
        verbose: bool,
    ) {
        use std::sync::{Arc, Mutex};
        use std::io::Read;
        
        let pty_writer = Arc::new(Mutex::new(pty_writer));
        let mut buffer = [0u8; 1024];
        let mut byte_buffer = Vec::new();

        if verbose {
            println!("üìù [stdin‚Üípty-raw] Starting raw input reading loop with terminal control");
        }

        // „Çø„Éº„Éü„Éä„É´„ÇíRAW„É¢„Éº„Éâ„Å´Ë®≠ÂÆö
        #[cfg(unix)]
        let original_termios = unsafe {
            let mut termios: libc::termios = std::mem::zeroed();
            let mut original_termios: Option<libc::termios> = None;
            
            if libc::tcgetattr(libc::STDIN_FILENO, &mut termios) == 0 {
                original_termios = Some(termios);
                
                // RAW„É¢„Éº„ÉâË®≠ÂÆö: ÂÖ•Âäõ„ÅÆÂç≥Â∫ßÂá¶ÁêÜ„Å®„Ç®„Ç≥„ÉºÁÑ°ÂäπÂåñ
                termios.c_lflag &= !(libc::ICANON | libc::ECHO | libc::ECHONL | libc::ISIG);
                termios.c_iflag &= !(libc::ICRNL | libc::INLCR | libc::IXON | libc::IXOFF);
                termios.c_oflag &= !libc::OPOST;
                termios.c_cc[libc::VMIN] = 1;  // ÊúÄÂ∞èË™≠„ÅøÂèñ„ÇäÊñáÂ≠óÊï∞
                termios.c_cc[libc::VTIME] = 0; // „Çø„Ç§„É†„Ç¢„Ç¶„ÉàÁÑ°Âäπ
                
                if libc::tcsetattr(libc::STDIN_FILENO, libc::TCSANOW, &termios) == 0 {
                    if verbose {
                        println!("üìù [stdin‚Üípty-raw] Terminal set to raw mode");
                    }
                } else {
                    if verbose {
                        eprintln!("‚ö†Ô∏è  Failed to set terminal raw mode");
                    }
                }
            } else {
                if verbose {
                    eprintln!("‚ö†Ô∏è  Failed to get terminal attributes");
                }
            }
            
            original_termios
        };
        
        #[cfg(not(unix))]
        let original_termios: Option<()> = None;

        loop {
            // Áõ¥Êé•Ê®ôÊ∫ñÂÖ•Âäõ„Åã„Çâ„Éê„Ç§„Éà„ÇíË™≠„ÅøÂèñ„Çä
            let result = tokio::task::spawn_blocking(move || {
                let mut stdin = std::io::stdin();
                match stdin.read(&mut buffer) {
                    Ok(n) => Ok((n, buffer.to_vec())),
                    Err(e) => Err(e),
                }
            }).await;

            match result {
                Ok(Ok((0, _))) => break, // EOF
                Ok(Ok((n, read_buffer))) => {
                    // Ë™≠„ÅøÂèñ„Å£„Åü„Éê„Ç§„Éà„ÇíÁ¥ØÁ©ç„Éê„ÉÉ„Éï„Ç°„Å´ËøΩÂä†
                    byte_buffer.extend_from_slice(&read_buffer[..n]);
                    
                    if verbose {
                        // „Ç®„Çπ„Ç±„Éº„Éó„Ç∑„Éº„Ç±„É≥„Çπ„ÇíÂèØË¶ñÂåñ
                        let mut debug_str = String::new();
                        for &byte in &read_buffer[..n] {
                            match byte {
                                27 => debug_str.push_str("ESC"),
                                10 => debug_str.push_str("\\n"),
                                13 => debug_str.push_str("\\r"),
                                9 => debug_str.push_str("\\t"),
                                91 => debug_str.push_str("["),
                                65..=90 | 97..=122 => debug_str.push(byte as char),
                                _ if byte >= 32 && byte <= 126 => debug_str.push(byte as char),
                                _ => debug_str.push_str(&format!("\\x{:02x}", byte)),
                            }
                        }
                        println!("üìù [stdin‚Üípty-raw] Read {} bytes: [{}] raw: {:?}", n, debug_str, &read_buffer[..n]);
                    }
                    
                    // UTF-8ÊñáÂ≠óÂ¢ÉÁïå„ÇíË¶ã„Å§„Åë„Å¶Âá¶ÁêÜ
                    let mut processed_bytes = 0;
                    
                    while processed_bytes < byte_buffer.len() {
                        // ÊÆã„Çä„ÅÆ„Éê„Ç§„Éà„ÅßUTF-8ÊñáÂ≠ó„ÅÆÈñãÂßã„ÇíÊé¢„Åô
                        let remaining = &byte_buffer[processed_bytes..];
                        
                        // UTF-8ÊñáÂ≠ó„Å®„Åó„Å¶ÊúâÂäπ„Å™ÊúÄÂ§ßÈï∑„ÇíË¶ã„Å§„Åë„Çã
                        match std::str::from_utf8(remaining) {
                            Ok(valid_str) => {
                                // ÂÖ®„Å¶ÊúâÂäπ„Å™UTF-8ÊñáÂ≠óÂàó
                                if !valid_str.is_empty() {
                                    if verbose {
                                        let display_input = valid_str.replace('\n', "\\n").replace('\r', "\\r");
                                        println!("üìù [stdin‚Üípty-raw] \"{}\" (bytes: {:?})", display_input, valid_str.as_bytes());
                                    }

                                    // PTY„Å´Êõ∏„ÅçËæº„Åø
                                    let result = tokio::task::spawn_blocking({
                                        let pty_writer = pty_writer.clone();
                                        let input = valid_str.to_string();
                                        move || {
                                            use std::io::Write;
                                            let mut writer = pty_writer.lock().unwrap();
                                            writer.write_all(input.as_bytes())?;
                                            writer.flush()?;
                                            Ok::<(), std::io::Error>(())
                                        }
                                    }).await;

                                    if let Err(e) = result {
                                        if verbose {
                                            eprintln!("üì° Spawn blocking error for stdin write: {}", e);
                                        }
                                        break;
                                    } else if let Err(e) = result.unwrap() {
                                        if verbose {
                                            eprintln!("üì° Write error to PTY: {}", e);
                                        }
                                        break;
                                    }
                                }
                                
                                // ÂÖ®‰Ωì„ÇíÂá¶ÁêÜÂÆå‰∫Ü
                                processed_bytes = byte_buffer.len();
                                break;
                            }
                            Err(utf8_error) => {
                                // ‰∏ÄÈÉ®„Å†„ÅëÊúâÂäπ„ÄÅ„Åæ„Åü„ÅØ‰∏çÂÆåÂÖ®„Å™UTF-8„Ç∑„Éº„Ç±„É≥„Çπ
                                let valid_up_to = utf8_error.valid_up_to();
                                
                                if valid_up_to > 0 {
                                    // ÊúâÂäπ„Å™ÈÉ®ÂàÜ„ÇíÂá¶ÁêÜ
                                    let valid_part = &remaining[..valid_up_to];
                                    if let Ok(valid_str) = std::str::from_utf8(valid_part) {
                                        if !valid_str.is_empty() {
                                            if verbose {
                                                let display_input = valid_str.replace('\n', "\\n").replace('\r', "\\r");
                                                println!("üìù [stdin‚Üípty-raw] \"{}\" (bytes: {:?})", display_input, valid_str.as_bytes());
                                            }

                                            // ÊúâÂäπÈÉ®ÂàÜ„ÇíPTY„Å´Êõ∏„ÅçËæº„Åø
                                            let result = tokio::task::spawn_blocking({
                                                let pty_writer = pty_writer.clone();
                                                let input = valid_str.to_string();
                                                move || {
                                                    use std::io::Write;
                                                    let mut writer = pty_writer.lock().unwrap();
                                                    writer.write_all(input.as_bytes())?;
                                                    writer.flush()?;
                                                    Ok::<(), std::io::Error>(())
                                                }
                                            }).await;

                                            if let Err(e) = result {
                                                if verbose {
                                                    eprintln!("üì° Spawn blocking error for stdin write: {}", e);
                                                }
                                                break;
                                            } else if let Err(e) = result.unwrap() {
                                                if verbose {
                                                    eprintln!("üì° Write error to PTY: {}", e);
                                                }
                                                break;
                                            }
                                        }
                                    }
                                    processed_bytes += valid_up_to;
                                } else {
                                    // ÊúÄÂàù„Åã„ÇâÁÑ°Âäπ - ‰∏çÂÆåÂÖ®„Å™UTF-8„Ç∑„Éº„Ç±„É≥„Çπ„ÅÆÂèØËÉΩÊÄß
                                    // Ê¨°„ÅÆË™≠„ÅøÂèñ„Çä„ÇíÂæÖ„Å§„Åü„ÇÅ„Å´„É´„Éº„Éó„ÇíÊäú„Åë„Çã
                                    break;
                                }
                            }
                        }
                    }
                    
                    // Âá¶ÁêÜÊ∏à„Åø„Éê„Ç§„Éà„Çí„Éê„ÉÉ„Éï„Ç°„Åã„ÇâÂâäÈô§
                    if processed_bytes > 0 {
                        byte_buffer.drain(..processed_bytes);
                    }
                    
                    // „Éê„ÉÉ„Éï„Ç°„ÅåÂ§ß„Åç„Åè„Å™„Çä„Åô„Åé„ÅüÂ†¥Âêà„ÅÆ„Ç¨„Éº„ÉâÔºàÁÑ°Âäπ„Å™„Éá„Éº„Çø„ÅÆËìÑÁ©ç„ÇíÈò≤„ÅêÔºâ
                    if byte_buffer.len() > 16 {
                        if verbose {
                            eprintln!("‚ö†Ô∏è  Clearing input buffer due to invalid UTF-8 sequence");
                        }
                        byte_buffer.clear();
                    }
                }
                Ok(Err(e)) => {
                    if verbose {
                        eprintln!("üì° Read error from stdin: {}", e);
                    }
                    break;
                }
                Err(e) => {
                    if verbose {
                        eprintln!("üì° Spawn blocking error: {}", e);
                    }
                    break;
                }
            }
        }
        
        // „Çø„Éº„Éü„Éä„É´Ë®≠ÂÆö„ÇíÂæ©ÂÖÉ
        #[cfg(unix)]
        if let Some(original) = original_termios {
            unsafe {
                if libc::tcsetattr(libc::STDIN_FILENO, libc::TCSANOW, &original) == 0 {
                    if verbose {
                        println!("üìù [stdin‚Üípty-raw] Terminal settings restored");
                    }
                } else {
                    if verbose {
                        eprintln!("‚ö†Ô∏è  Failed to restore terminal settings");
                    }
                }
            }
        }
    }

    /// „Éó„É≠„Çª„ÇπÁõ£Ë¶ñ„Çø„Çπ„ÇØÈñãÂßã
    async fn start_process_monitoring(&self) -> JoinHandle<()> {
        let _launcher_id = self.launcher_id.clone();
        let verbose = self.verbose;
        let mut process_monitor = ProcessMonitor::new();

        tokio::spawn(async move {
            let mut interval = tokio::time::interval(tokio::time::Duration::from_secs(5));

            loop {
                interval.tick().await;
                
                let process_info = process_monitor.get_process_info().await;
                
                if verbose {
                    println!("üìä Process: CPU {:.1}%, Memory {}MB, Children {}",
                        process_info.cpu_percent,
                        process_info.memory_mb,
                        process_info.child_count
                    );
                }

                // TODO: Monitor „Å´ÈÄÅ‰ø°
                // „Åì„ÅÆ„Çª„ÇØ„Ç∑„Éß„É≥„ÅØÂæå„ÅßÂÆüË£Ö
            }
        })
    }

    /// ÂàáÊñ≠„É°„ÉÉ„Çª„Éº„Ç∏ÈÄÅ‰ø°
    async fn send_disconnect_message(&mut self) -> Result<()> {
        let message = LauncherToMonitor::Disconnect {
            launcher_id: self.launcher_id.clone(),
            timestamp: chrono::Utc::now(),
        };

        self.send_message(message).await?;

        if self.verbose {
            println!("üì¥ Sent disconnect message to monitor");
        }

        Ok(())
    }

    /// „É°„ÉÉ„Çª„Éº„Ç∏ÈÄÅ‰ø°
    async fn send_message(&mut self, message: LauncherToMonitor) -> Result<()> {
        let stream = self.socket_stream.as_mut()
            .ok_or_else(|| anyhow::anyhow!("Not connected to monitor"))?;

        let json_data = serde_json::to_string(&message)?;
        let data_with_newline = format!("{}\n", json_data);

        stream.write_all(data_with_newline.as_bytes()).await?;
        stream.flush().await?;

        Ok(())
    }

    /// Êé•Á∂öÁä∂ÊÖãÁ¢∫Ë™ç
    pub fn is_connected(&self) -> bool {
        self.socket_stream.is_some()
    }

    /// Launcher ÊÉÖÂ†±ÂèñÂæó
    pub fn get_info(&self) -> LauncherInfo {
        LauncherInfo {
            id: self.launcher_id.clone(),
            project: self.project_name.clone(),
            claude_args: self.claude_wrapper.get_args().to_vec(),
            session_id: self.session_id.clone(),
        }
    }
}

/// Launcher ÊÉÖÂ†±
#[derive(Debug, Clone)]
pub struct LauncherInfo {
    pub id: String,
    pub project: Option<String>,
    pub claude_args: Vec<String>,
    pub session_id: String,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_launcher_client_creation() {
        let client = LauncherClient::new(vec!["--help".to_string()], false);
        assert!(!client.is_connected());
        assert!(client.launcher_id.starts_with("launcher-"));
    }

    #[test]
    fn test_launcher_info() {
        let client = LauncherClient::new(vec!["--project".to_string(), "test".to_string()], false);
        let info = client.get_info();
        
        assert_eq!(info.claude_args, vec!["--project", "test"]);
        assert_eq!(info.project, Some("test".to_string()));
    }
}